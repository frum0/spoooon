--------------------
------ Task 1 ------
--------------------

1. Базовое понимание java-приложения

Создать в папке src класс java следующего вида:
(если в New нет опции Java Class - задать через меню src -> Mark Directory As -> Sources Root)

public class MyFirstClass {
    public static void main(String[] args) {
        // комментарий
    }
}

2. Общие правила именования

Имя класса всегда начинается с большой буквы (и именно с буквы) и может содержать цифры и символ _
Имя переменной всегда начинается с маленькой буквы (и именно с буквы) и может содержать цифры и символ _

вот эта часть внутри класса называется стартовым методом:

    public static void main(String[] args) {
        // комментарий
    }

чтобы запустить Java-программу, необходимо, чтобы программа содержала как минимум один класс со стартовым методом,
собственно стартовый метод и содержащийся в нем код - страртовая точка, с которой начинает выполняться Java-приложение.

Ключевое слово main является зарезервированным именем стартового метода в Java.
Ключевые слова public, static, void. а также понятие метода мы будем разбирать в последующих уроках.
Пока нужно просто запомнить (или даже зазубрить), что Java-приложение начинается с такого строительного элемента.

Скомпилировать и запустить программу MyFirstClass.
Добавить в программу внутрь метода main стандартный вывод (STDOUT) любой произвольной строки
(в java стандартный вывод строки выполняется командой System.out.println("какая-то строка");


3. базовые типы данных

byte - базовый целочисленный тип размером в один байт
int - базовый целочисленный тип
long - расширенный целочисленный тип
float - базовый вещественный тип
double - расширенный вещественный тип
boolean - логичеcкий тип, может принимать значения true или false
String - строковой тип


4. Присвоение значений переменнным

Переменная в Java - это базовый строительный кирпичик структуры данных приложения,
переменная должна иметь имя (выше писалось - всегда начинается с маленькой буквы (и именно с буквы) и может содержать цифры и символ _),
переменной мы можем присвоить некоторое значение, определяемое ее типом,

Java - язык со строгой типизацией переменных, это означает что перед присвоением значения переменной
нам нужно явно указать ее тип (иными словами - ОБЪЯВИТЬ переменную):

int a;
long b;
boolean c;
String s;

Присваивать значения переменным можно сразу при объявлении:

long b = 1000000;
boolean c = true;
String s = "some string 1";

либо в любом месте программы после объявления:

a = 1000;
...
b = 1000000;
...
c = true;
...
s = "some string 1";

логический тип также может быть задан условием сравнения двух других переменных либо значений, например:

boolean c = a == b;
boolean c = a <= b;
boolean c = a >= b;
boolean c = a < b;
boolean c = a > b;
boolean c = a > 10;
boolean c = a > 200;
и т.д.

ключевое слово == используется для сравнения значений и выглядит таким образом, чтобы отличаться от одинарного знака равенства,
который используется для присвоения значений переменным.


5. Константы

для задания констант используется ключевое слово final:

final int fa = 1000;
final long fb = 1000000;
final boolean fc = true;
final String fs = "some string 2";

это означает, что значение задается один раз и нигде далее в программе не может быть переопределено.


6. Массивы

массив - это набор значений одного типа, доступ к которым (значениям) осуществляется по целому числовому указателю (тип int)
объявляются массивы с помощью ключевого слова [] следующим образом (для вышеперечисленных типов, которые мы разобрали):

int[] a1;
long[] a2;
boolean[] a3;
String[] a4;

инициализация массива выглядит так:

int[] a1 = new int[5];
long[] a2 = new long[10];
boolean[] a3 = new boolean[5];
String[] a4 = new String[10]

Обратите внимание, что здесь используется ключевое слово new, которое создаст нам новый ОБЪЕКТ массива,
более подробно про создание (инициализацию) объектов расскажу чуть позже.

Число внутри скобок означает размер массива, например int[5] будет означать, что массив содержит 5 элементов (значений int)
это значение постоянно и не может быть изменено, если нужно поменять размер массива - его нужно инициализировать заново

заполнение массива значениями выглядит так (пример для int[] a1 = new int[5]):

a1[0] = 12;
a1[1] = 12312;
a1[2] = 234234;
a1[3] = 4545;
a1[4] = 1

обрати внимание, что указатель начинается с 0 - т.е. первый элемент массива имеет указатель 0, второй - единицу и т.д.


7. Написать в существующей программе код, который будет делать следующее:
- присваивать значения переменным типов byte, int, long, float, double, boolean, String
- присваивать значения константам типов byte, int, long, float, double, boolean, String
- выводить в STDOUT последовательно значения всех заданных переменных
- создать массив типа int небольшого размера (5-10) и заполнить его значениями
- вывести в STDOUT последовательно все значения массива


8. Подготовить ответы на вопросы устно:

что такое стандартный вывод (STDOUT)?
как в java выглядят комментарии в коде?
какие правила именования для переменных?
какие правила именования для классов?
какой вид типизации переменных в Java?
какие еще есть виды типизации вообще?
как в java задаются константы?
какие значения по умолчанию существуют для типов byte, int, long, float, double, boolean, String?
сколько байт в памяти занимают переменные типов byte, int, long, float, double, boolean, String?
какие правила инициализации и заполнения массивов?
что такое указатель массива?
какое максимальное количество элементов массива возможно в java?
2147483647

task cost 1000
total cost 1000





--------------------
------ Task 2 ------
--------------------

Базовое понимание объектов и классов

1. Класс в Java указывает на определенную категорию объектов и выступает в качестве шаблона для создания таких объектов.
Объект проявляет свойства и поведение, определенное его классом.
Объект содержит ПОЛЯ и МЕТОДЫ, определенные в классе (шаблоне),
Поля называются свойствами объекта и являются по сути переменными, которые могут хранить некоторое значения.
Методы определяют поведение объекта и представлют собой обособленные части программного кода, которые могут принимать
ряд параметров, производить некие действия и при необходимости возвращать значение (результат).

Иными словами - поля определяют структуру данных класса и отвечают на вопрос КАКИЕ данные может содержать объект,
методы же отвечают на вопрос - что мы можем СДЕЛАТЬ с данными внутри объекта и как правило очень часто имена методов и являются глаголом.

Если метод не возращает значения, то в его описании используется ключевое слово void (мнимый тип означающий отсутствие типов)
Если метод возвращает значение (вместо void указан значимый тип данных), то последняя (либо единственная) строка в методе должна начинаться с ключевого слова return:

    return переменная_либо_выражение;

В скобках после имени метода мы можем определить набор параметров (один или более) которые может принимать метод при его вызове,
параметр - это именованное значение (по аналогии с переменной) которое передается в метод извне и может использоваться в
программном коде внетри метода.

Методы принято именовать с маленькой буквы.

пример:

public class SomeClass {
    // поля
    int intField;
    long longField;
    boolean booleanField;
    String stringField;

    // методы
    public void setIntField(int intField) {
        this.intField = intField;
    }

    public int getIntField() {
        return this.intField;
    }
}

здесь помимо void мы видим еще новое слово this,
оно означает. что мы обращаемся к полю (либо методу) конкретного ЭКЗЕМПЛЯРА (объекта класса)

В данном случае мы определили в классе 2 метода для заполнения и получения значения из поля intField


2. Инстанциирование (создание) объекта

Для создания нового экземпляра класса используется ключевое слово new:

    SomeClass a = new SomeClass();

в результате значение a будет содержать ссылку на новый объект.
Ранее мы уже видели применение new в случае создания массивов, т.к. массив является объектным типом данных.

ВАЖНО ПОНИМАТЬ, что, если мы создаем к примеру 2 или больше объекта класса SomeClass:

SomeClass sc1 = new SomeClass();
SomeClass sc2 = new SomeClass();
...

то sc1 и sc2 будут содержать ссылки на РАЗНЫЕ экземпляры класса SomeClass со своими собственными наборами полей.

Обращение к полям и методам экземпляра класса (объекта) выполняется с помощью точки после имени экземпляра
(среда разработки, в нашем случае idea, как правило сама предоставляет выбор доступных полей и методов после простановки точки)
в нашем случае доступны будут все поля и методы, если для них не указан модификатор private (см. ниже),
например, заполнить поле экземпляра мы можем двумя способами - как напрямую обратившись к полю, так и вызвав метод set:

sc1.intField = 12345;
sc1.setIntField(12345);
результат в обоих случаях идентичный - поле получает значение 12345

также получить значение из поля и вывести его в STDOUT можно как напрямую обратившись к полю, так и вызвав метод get:

System.out.println(sc1.intField);
System.out.println(sc1.getIntField);

В просторечии между программистами такие методы, которые заполняют поля и получают из полей значения
называются геттерами и сеттерами.

3. Модификатор private

Ключевое слово private используется для ограничения видимости полей и методов,
если мы используем данный модификатор, то поле или метод будут доступны только ИЗНУТРИ самого класса,

пример:

public class SomeClassWithPrivateFields {
    // поля
    private int intField;
    private long longField;
    private boolean booleanField;
    private String stringField;

    // методы
    public void setIntField(int intField) {
        this.intField = intField;
    }

    public int getIntField() {
        return this.intField;
    }
}

Создадим два экземпляра классов:

SomeClass sc = new SomeClass();
SomeClassWithPrivateFields scwpf = SomeClassWithPrivateFields();

если в первом случае мы можем выполнить обращение к полю intField напрямую и присвоить ему значение

sc.intField = 1234;

то во втором случае поле будет недоступно снаружи класса и присвоить ему значение мы сможем только через setter-метод,
если он был для данного поля определен:

scwpf.setIntField(1234);

Такая реализация считается более грамотной с точки зрения ООП, т.к. мы не даем прямого доступа к полю объекта,
а предлагаем некую реализацию для его заполнения, которая может отличаться от простого присвоения значения
(например нам нужно сохранить в истории событие изменения значения поля либо вывести в лог сообщение)


4. Конструктор класса

Конструктор - специфический метод, который именуется именем класса и используется для инициализации полей значениями сразу при создании объекта

пример:

public class SomeClassWithConstructor {
    // поля
    int intField;
    long longField;
    boolean booleanField;
    String stringField;

    // конструктор, инициализирующий все поля
    public SomeClassWithConstructor(int intField, long longField, boolean booleanField, String stringField) {
       this.intField = intField;
       this.longField = longField;
       this.booleanField = booleanField;
       this.stringField = stringField;
    }

    // методы
    public void setIntField(int intField) {
        this.intField = intField;
    }

    public int getIntField() {
        return this.intField;
    }
}

При использовании конструкторов ВАЖНО понимать следующее:

- если в классе конструктор явно не определен, существует неявный конструктор без аргументов (конструктор по умолчанию),
который мы используем при создании экземпляров к примеру для SomeClass:

SomeClass sc = new SomeClass();

- если в классе явно задан конструктор с аргументами, то конструктор по умолчанию использоваться не будет, и если нам понадобится
подобный конструктор (без аргументов) то нужно определить его свмостоятельно.

Например экземпляр SomeClassWithConstructor мы можем теперь получить только так (пример):

SomeClassWithConstructor scwc = new SomeClassWithConstructor(1000, 10000, true, "abc");


5. Immutable-классы или объект как константа

Мы можем использовать внутри объекта final-поля и задавать их через конструктор (собственно по другому и не получится),
в результате мы получаем неизменяемый объект (поля в котором не могут быть переопределены):

public class SomeImmutableClass {
    // поля
    final int intField;
    final long longField;
    final boolean booleanField;
    final String stringField;

    // конструктор, инициализирующий все поля
    public SomeImmutableClass(int intField, long longField, boolean booleanField, String stringField) {
       this.intField = intField;
       this.longField = longField;
       this.booleanField = booleanField;
       this.stringField = stringField;
    }

    // методы
    public int getIntField() {
        return this.intField;
    }
}

Если ты обратил внимание, то в этом классе нет set...() методов, т.к. final поля заполняются один раз
при нициализации обьекта в контрукторе и далее не могут быть изменены,
если мы даже добавим сеттер - компилятор не даст собрать такой класс.

Иными словами, final-поле ДОЛЖНО быть инициализировано либо сразу при объявлении, либо в каждом из объявленных конструкторов.

6. Задание 1

- создать в приложении новые классы:

SomeClass
SomeClassWithPrivateFields
SomeClassWithConstructor
SomeImmutableClass

- дополнить классы методами get...() и set...() для всех 4-х полей (я в примерах описал методы только для int поля)

- создать новый стартовый класс для TASK 2 (отличный от Chtoeto) внутри которого:
  - создать по экземпляру вышеперечисленных 4-х классов
  - написать код, заполняющий поля объектов значениями, как при прямом обращению к полю, так и через методы set...()
  - написать код, выводящий в STDOUT значения полей, как путем прямого обращению к полю, так и через методы get...()

7. Задание 2 (extra cost value)

для понимания, стек - это структура данных, которую можно описать как полую трубку,
закрытую с одного конца, в которую мы суем с одного конца шарики со значениями,
т.е. если мы поместили в стек по очереди шарики со значениями 23, 12, 5, 7, 9
то доставать мы их сможем только в следующем порядке: 9, 7, 5, 12, 23

разработать класс Stack для реализации стека из 5 значений int,
необходимо добавить поля для хранения данных и написать код для методов:

public class Stack {

    // поместить значение в стек
    public void put(int a) {
       ...
    }

    // вынуть верхнее значение из стека
    public int pull() {
       ...
    }

    // посмотреть верхнее значение в стеке, но не вынимать
    public int get() {
       ...
    }

    // выдать true если стек полон
    public boolean isFull() {
       ...
    }

    // выдать true если стек пуст
    public boolean isEmpty() {
       ...
    }

}

все необходимое для этого задания пройдено в 2-х уроках


8. вопросы для обсуждения

- чем класс отличается от объекта?
- что такое поля и методы объекта?
- чем приватные поля и методы отличаются от обычных?
- сколько видов методов исходя из наличия параметров и наличия возвращаемого значения можно насчитать?
- какой вид метода при этом можно сравнить с функцией?
- что такое конструктор?
- что такое конструктор по умолчанию?
- может ли конструктор быть приватным?
- что такое immutable-класс?




--------------------
------ Task 3 ------
--------------------


1. Базовые принципы ООП - инкапсуляция, наследование и полиморфизм

На данный момент мы можем уже базово разобрать два принципа - инкапсуляцию и наследование,
итак,
инкапсуляция (мы по сути уже коснулись этого в примерах) -
это упаковка некоторого поведения (программного кода), определяющего (к примеру) изменение данных объекта (значений полей),
внутрь самого объекта (в частности внутрь методов),
иными словами - инкапсуляция в данном случае означает, что поля:
- недоступны для изменения напрямую снаружи объекта
- изменение полей производится методами самого объекта в рамках правил, заданных программно в самих этих методах.

выше мы как раз разбирали случай с сеттерами:

public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    // сеттер
    public void setIntField(int intField) {
        this.intField = intField;
    }
}

в данном случае метод setIntField() определяет то, как будет изменяться поле intField,
в методе выше значение передается как есть, но к примеру мы можем сделать так:

    public void setIntField(int intField) {
        if (intField >= 0) {
            this.intField = intField;
        }
    }

мы определили условие, при котором поле сможет принимать только положительные значения,
иными словами мы ИНКАПСУЛИРОВАЛИ логику, при которой поле никогда не будет отрицательным.


2. Класс Object и наследование

Наследование в Java - достаточно обширная тема, разбирать будем постепенно.
Сейчас нам достаточно понять то, что в общем случае наследование означает, что все публичные поля и методы
родительского класса наследуются дочерним классом и доступны для использования в объекте дочернего класса без явного объявления.

ВАЖНО: В Java существует родительский класс Object, являющийся предком всех объектов.
От класса Object в Java НЕЯВНО наследуются все объекты (Явное наследование мы разберем чуть ниже).

Для явного объявления наследования текущего класса от любого другого существующего (кроме Object)
используется ключевое слово extends:

// возьмем наш старый пример
public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    // сеттер
    public void setIntField(int intField) {
        this.intField = intField;
    }
}

// и создадим наследника вообще без всего:
public class ChildClassWithPrivateFields extends SomeClassWithPrivateFields {

}

если мы инстанциируем экземпляр ChildClassWithPrivateFields, то публичный метод setIntField будет доступен и в нем:

ChildClassWithPrivateFields ccwpf = new ChildClassWithPrivateFields();
ccwpf.setIntField(12345);

Т.е. иными словами родительский класс будет как бы вложен внутрь дочернего, или наооброт,
дочерний является оболочкой вокруг родительского (можно привести аналогию с матрешкой).


3. Типы ссылок на объект, ключевое слово instanceof и явное приведение типов

Выше мы инстанциировали объект дочернего класса

ChildClassWithPrivateFields ccwpf = new ChildClassWithPrivateFields();

выглядит логично, что тип объектной переменной (ссылки на объект) является собственно типом класса, который мы инстанциируем,
НО, Java позволяет нам в качестве типа ссылки указывать любой родительский тип, если он существует,

например можно сделать так:
SomeClassWithPrivateFields ccwpf = new ChildClassWithPrivateFields();

или даже так:
Object ccwpf = new ChildClassWithPrivateFields();

здесь ВАЖНО понимать, что во всех этих случаях будет создан объект класса ChildClassWithPrivateFields,
т.е. иными словами тип создаваемого объекта всегда определяется тем что указано после ключевого слова new,
в нашем случае:
new ChildClassWithPrivateFields()

а тип ссылки указывает на то, какие методы и поля нам будут доступны, т.е. мы получим доступ только к тем полям и методам, которые доступны в классе,
который объявлен для объектной переменной (ссылки на объект) - ccwpf.

Далее, допустим мы где-то в коде присвоили ссылке (переменной)

Object o

какой-то объект,
как нам проверить, экземпляром какого класса является этот объект?
Одним из способов является использование ключевого слова instanceof,
оно позволяет проверить, является ли объект по ссылке (переменной) экземпляром конкретного класса,
условие (для проверки на экземпляр ChildClassWithPrivateFields) будет выглядить так:

o instanceof ChildClassWithPrivateFields

условие возвратит true, если o является экземпляром класса ChildClassWithPrivateFields,
в противном случае возвратит false.

Далее, а можем ли мы, имея переменную

Object o

которая на самом деле указывает на объект класса ChildClassWithPrivateFields (и мы в этом уверены)
каким то образом переопределить переменную на тип ChildClassWithPrivateFields чтобы использовать методы этого класса?
Да, можем,
для этого нам нужно объявить еще одну переменную нужного типа и воспользоваться ЯВНЫМ преобразованием типов, которое
в коде выглядит так:

ChildClassWithPrivateFields сс = (ChildClassWithPrivateFields) o;

Хорошим тоном (чтобы не нарваться на ошибку приведения типов) является как раз проверять тип объекта
перед таким преобразованием:

if (o instanceof ChildClassWithPrivateFields) {
    ChildClassWithPrivateFields сс = (ChildClassWithPrivateFields) o;
    // далее какой-то код
    ...
}


5. метод equals() и сравнение объектов

метод equals() предназначен для сравнения текущего объекта с другим объектом (экземпляром) ЭТОГО ЖЕ класса
метод equals() интересен тем, что этот метод изначально определен в классе Object и в нем он работает таким образом,
что сравнивает системные уникальные идентификаторы объектов, и т.к. каждый идентификатор уникален,
то получается что и каждый из объектов также будет уникален и не равен никакому другому (метод будет возвращать false если
только мы не сравниваем объект с самим собой),
чтобы сравнивать объекты исходя из их реального назначения, метод equals должен быть ПЕРЕОПРЕДЕЛЕН в текущем объекте
и внутри метода должно быть запрограммировано соответствующее поведение, иными словами,
правила сравнивания объектов некоторого класса должны быть ИНКАПСУЛИРОВАНЫ в методе equals() класса.

// и опять возьмем наш старый пример
public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    public int getIntField() {
        return this.intField;
    }

    public void setIntField(int intField) {
        this.intField = intField;
    }
}

если мы хотим сравнивать объекты данного класса исходя из того значения, которое будет присвоено полю intField,
то нам нужно ПЕРЕОПРЕДЕЛИТЬ метод equals() родительского класса Object:

public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    public int getIntField() {
        return this.intField;
    }

    public void setIntField(int intField) {
        this.intField = intField;
    }

    @Override
    public boolean equals(Object o) {
        // проверяем, что в метод пришел именно экземпляр SomeClassWithPrivateFields
        if (o instanceof SomeClassWithPrivateFields) {
            // приводим аргумент метода к текущему типу объекта, чтобы мы могли обратиться к его методу
            SomeClassWithPrivateFields scwpf = (SomeClassWithPrivateFields) o;
            if (this.intField == scwpf.getIntField()) {
                return true;
            }
        }
        return false;
    }
}

лирическое отступление:
над описанием метода equals() мы видим такую загогулину: @Override
это называется АННОТАЦИЯ
Аннотация вообще, это нечто среднее между комментарием и исполняемым кодом, сами аннотации не являются ключевым словом для
выполнения какого-то действия, но могут указывать компилятору либо самой java-машине (JRE, Java Runtime Environment)
на необходимость каких-то дополнительных действий типа проверок и т.п.
Тему с аннотациями мы будем разбирать позже, в данном случае мы коснулись аннотации @Override и я решил это сразу пояснить.
Хорошим тоном является помечать аннотацией @Override каждый переопредляемый метод.
На работе программы это НИКАК не сказывается, все будет работать и без данной аннотации,
НО,
@Override говорит компилятору, что данный метод переопределен, т.е. у родительского класса должен быть аналогичный метод,
если у родительского класса аналогичный метод остутствует - компилятор выдаст предупреждение,
это сделано для использования в больших проектах для помощи в отслеживании труднообнаружимых ошибок.
конец лирического отступления


6. вопросы и задания

- что такое инкапсуляция?
- как ты понял наследование?
- что за класс Object?
- что такое явное и неяное наследование?
- всегда ли тип объектной переменной должен совпадать с типом присваемого объекта?
- что такое ключевое слово instanceof?
- что такое явное приведение типов?
- как работает сравнение объектов в Java?





IN PROGRESS...
--------------------
------ Task 4 ------
--------------------

1. Класс String и его методы
indexOf("")
startWith("")
endsWith("")
substring(0,1)
toUpperCase()
toLowerCase()
trim()
split("")
replace("","")
isEmpty()
length()
concat("")
compareTo("")
equals("")
equalsIgnoreCase("")

