--------------------
------ Task 1 ------
--------------------

1. Базовое понимание java-приложения

Создать в папке src класс java следующего вида:
(если в New нет опции Java Class - задать через меню src -> Mark Directory As -> Sources Root)

public class MyFirstClass {
    public static void main(String[] args) {
        // комментарий
    }
}

2. Общие правила именования

Имя класса всегда начинается с большой буквы (и именно с буквы) и может содержать цифры и символ _
Имя переменной всегда начинается с маленькой буквы (и именно с буквы) и может содержать цифры и символ _

вот эта часть внутри класса называется стартовым методом:

    public static void main(String[] args) {
        // комментарий
    }

чтобы запустить Java-программу, необходимо, чтобы программа содержала как минимум один класс со стартовым методом,
собственно стартовый метод и содержащийся в нем код - стартовая точка, с которой начинает выполняться Java-приложение.

Ключевое слово main является зарезервированным именем стартового метода в Java.
Ключевые слова public, static, void. а также понятие метода мы будем разбирать в последующих уроках.
Пока нужно просто запомнить (или даже зазубрить), что Java-приложение начинается с такого строительного элемента.

Скомпилировать и запустить программу MyFirstClass.
Добавить в программу внутрь метода main стандартный вывод (STDOUT) любой произвольной строки
(в java стандартный вывод строки выполняется командой System.out.println("какая-то строка");


3. базовые типы данных

byte - базовый целочисленный тип размером в один байт
int - базовый целочисленный тип
long - расширенный целочисленный тип
float - базовый вещественный тип
double - расширенный вещественный тип
boolean - логичеcкий тип, может принимать значения true или false
String - строковой тип


4. Объявление переменных, присвоение значений переменнным и операции с переменными

Переменная в Java - это базовый строительный кирпичик структуры данных приложения,
переменная должна иметь имя (выше писалось - всегда начинается с маленькой буквы (и именно с буквы) и может содержать цифры и символ _),
переменной мы можем присвоить некоторое значение, определяемое ее типом,

Java - язык со строгой типизацией переменных, это означает что перед присвоением значения переменной
нам нужно явно указать ее тип (иными словами - ОБЪЯВИТЬ переменную):

int a;
long b;
boolean c;
String s;

Присваивать значения переменным можно сразу при объявлении:

long b = 1000000;
boolean c = true;
String s = "some string 1";

либо в любом месте программы после объявления:

a = 1000;
...
b = 1000000;
...
c = true;
...
s = "some string 1";

Объявляется переменная один раз, присваивать значение объявленной переменной можно столько раз, сколько потребуется.

Переменной можно присваивать как конкретные значения, так и другие переменные такого же типа, а также
математические выражения, содержащие значения и переменные:

int a;
int b;

a = 1000;
b = 100000;
a = b;
a = a + 200000;
a = a + b;
a = a * b;
a = a * (b - 100);
...
и т.д.

Логический тип также может быть задан условием сравнения двух других переменных либо значений, например:

boolean c = a == b;
boolean c = a <= b;
boolean c = a >= b;
boolean c = a < b;
boolean c = a > b;
boolean c = a > 10;
boolean c = a > 200;
...
и т.д.

обрати внимание, что ключевое слово == используется для сравнения значений и выглядит таким образом, чтобы отличаться от одинарного знака равенства,
который используется для присвоения значений переменным.

Математические выражения в общем виде описываются стандартными правилами, могут содержать явно указанные значения и переменные
а также знаки + (сложение) - (вычитание) * (умножение) / (деление) % (остаток от деления) и скобки для уточнения очередности операций


5. Константы

для задания констант используется ключевое слово final:

final int fa = 1000;
final long fb = 1000000;
final boolean fc = true;
final String fs = "some string 2";

это означает, что значение задается один раз и нигде далее в программе не может быть переопределено.


6. Массивы

массив - это набор значений одного типа, доступ к которым (значениям) осуществляется по целому числовому указателю (тип int)
объявляются массивы с помощью ключевого слова [] следующим образом (для вышеперечисленных типов, которые мы разобрали):

int[] a1;
long[] a2;
boolean[] a3;
String[] a4;

Перед тем, как перейти к работе с массивом, его нужно ИНИЦИАЛИЗИРОВАТЬ,
инициализация массива выглядит так:

int[] a1 = new int[5];
long[] a2 = new long[10];
boolean[] a3 = new boolean[5];
String[] a4 = new String[10]

Обратите внимание, что здесь используется ключевое слово new, которое создаст нам новый ОБЪЕКТ массива,
более подробно про создание (инициализацию) объектов расскажу чуть позже.

Число внутри скобок означает размер массива, например int[5] будет означать, что массив содержит 5 элементов (значений int)
это значение постоянно и не может быть изменено, если нужно поменять размер массива - его нужно инициализировать заново,

заполнение массива значениями может выглядеть так (пример для int[] a1 = new int[5]):

a1[0] = 12;
a1[1] = 12312;
a1[2] = 234234;
a1[3] = 4545;
a1[4] = 1;

Число в квадратных скобках называется УКАЗАТЕЛЕМ массива и служит для обращения к конкретному элементу,
обрати внимание, что указатель начинается с 0 - т.е. первый элемент массива имеет указатель 0, второй - единицу и т.д.


7. Написать в существующей программе код, который будет делать следующее:
- присваивать значения переменным типов byte, int, long, float, double, boolean, String
- присваивать значения константам типов byte, int, long, float, double, boolean, String
- выводить в STDOUT последовательно значения всех заданных переменных
- создать массив типа int небольшого размера (5-10) и заполнить его значениями
- вывести в STDOUT последовательно все значения массива


8. Подготовить ответы на вопросы устно:

что такое стандартный вывод (STDOUT)?
как в java выглядят комментарии в коде?
какие правила именования для переменных?
какие правила именования для классов?
какой вид типизации переменных в Java?
какие еще есть виды типизации вообще?
как в java задаются константы?
какие значения по умолчанию существуют для типов byte, int, long, float, double, boolean, String?
сколько байт в памяти занимают переменные типов byte, int, long, float, double, boolean, String?
какие правила инициализации и заполнения массивов?
что такое указатель массива?
какое максимальное количество элементов массива возможно в java?
2147483647

task cost 1000
total cost 1000





--------------------
------ Task 2 ------
--------------------

Базовое понимание объектов и классов

1. Класс в Java указывает на определенную категорию объектов и выступает в качестве шаблона для создания таких объектов.
Объект проявляет свойства и поведение, определенное его классом.
Объект содержит ПОЛЯ и МЕТОДЫ, определенные в классе (шаблоне),
Поля называются свойствами объекта и являются по сути переменными, которые могут хранить некоторое значения.
Методы определяют поведение объекта и представлют собой обособленные части программного кода, которые могут принимать
ряд параметров, производить некие действия и при необходимости возвращать значение (результат).

Иными словами - поля определяют структуру данных класса и отвечают на вопрос КАКИЕ данные может содержать объект,
методы же отвечают на вопрос - что мы можем СДЕЛАТЬ с данными внутри объекта и как правило очень часто имена методов и являются глаголом.

Если метод не возращает значения, то в его описании используется ключевое слово void (мнимый тип означающий отсутствие типов)
Если метод возвращает значение (вместо void указан значимый тип данных), то последняя (либо единственная) строка в методе должна начинаться с ключевого слова return:

    return переменная_либо_выражение;

В скобках после имени метода мы можем определить набор параметров (один или более) которые может принимать метод при его вызове,
параметр - это именованное значение (по аналогии с переменной) которое передается в метод извне и может использоваться в
программном коде внетри метода.

Методы принято именовать с маленькой буквы.

пример:

public class SomeClass {
    // поля
    int intField;
    long longField;
    boolean booleanField;
    String stringField;

    // методы
    public void setIntField(int intField) {
        this.intField = intField;
    }

    public int getIntField() {
        return this.intField;
    }
}

здесь помимо void мы видим еще новое слово this,
оно означает. что мы обращаемся к полю (либо методу) конкретного ЭКЗЕМПЛЯРА (объекта класса)

В данном случае мы определили в классе 2 метода для заполнения и получения значения из поля intField


2. Инстанциирование (создание) объекта

Для создания нового экземпляра класса используется ключевое слово new:

    SomeClass a = new SomeClass();

в результате значение a будет содержать ссылку на новый объект.
Ранее мы уже видели применение new в случае создания массивов, т.к. массив является объектным типом данных.

ВАЖНО ПОНИМАТЬ, что, если мы создаем к примеру 2 или больше объекта класса SomeClass:

SomeClass sc1 = new SomeClass();
SomeClass sc2 = new SomeClass();
...

то sc1 и sc2 будут содержать ссылки на РАЗНЫЕ экземпляры класса SomeClass со своими собственными наборами полей.

Обращение к полям и методам экземпляра класса (объекта) выполняется с помощью точки после имени экземпляра
(среда разработки, в нашем случае idea, как правило сама предоставляет выбор доступных полей и методов после простановки точки)
в нашем случае доступны будут все поля и методы, если для них не указан модификатор private (см. ниже),
например, заполнить поле экземпляра мы можем двумя способами - как напрямую обратившись к полю, так и вызвав метод set:

sc1.intField = 12345;
sc1.setIntField(12345);
результат в обоих случаях идентичный - поле получает значение 12345

также получить значение из поля и вывести его в STDOUT можно как напрямую обратившись к полю, так и вызвав метод get:

System.out.println(sc1.intField);
System.out.println(sc1.getIntField);

В просторечии между программистами такие методы, которые заполняют поля и получают из полей значения
называются геттерами и сеттерами.

3. Модификатор private

Ключевое слово private используется для ограничения видимости полей и методов,
если мы используем данный модификатор, то поле или метод будут доступны только ИЗНУТРИ самого класса,

пример:

public class SomeClassWithPrivateFields {
    // поля
    private int intField;
    private long longField;
    private boolean booleanField;
    private String stringField;

    // методы
    public void setIntField(int intField) {
        this.intField = intField;
    }

    public int getIntField() {
        return this.intField;
    }
}

Создадим два экземпляра классов:

SomeClass sc = new SomeClass();
SomeClassWithPrivateFields scwpf = SomeClassWithPrivateFields();

если в первом случае мы можем выполнить обращение к полю intField напрямую и присвоить ему значение

sc.intField = 1234;

то во втором случае поле будет недоступно снаружи класса и присвоить ему значение мы сможем только через setter-метод,
если он был для данного поля определен:

scwpf.setIntField(1234);

Такая реализация считается более грамотной с точки зрения ООП, т.к. мы не даем прямого доступа к полю объекта,
а предлагаем некую реализацию для его заполнения, которая может отличаться от простого присвоения значения
(например нам нужно сохранить в истории событие изменения значения поля либо вывести в лог сообщение)


4. Конструктор класса

Конструктор - специфический метод, который именуется именем класса и используется для инициализации полей значениями сразу при создании объекта

пример:

public class SomeClassWithConstructor {
    // поля
    int intField;
    long longField;
    boolean booleanField;
    String stringField;

    // конструктор, инициализирующий все поля
    public SomeClassWithConstructor(int intField, long longField, boolean booleanField, String stringField) {
       this.intField = intField;
       this.longField = longField;
       this.booleanField = booleanField;
       this.stringField = stringField;
    }

    // методы
    public void setIntField(int intField) {
        this.intField = intField;
    }

    public int getIntField() {
        return this.intField;
    }
}

При использовании конструкторов ВАЖНО понимать следующее:

- если в классе конструктор явно не определен, существует неявный конструктор без аргументов (конструктор по умолчанию),
который мы используем при создании экземпляров к примеру для SomeClass:

SomeClass sc = new SomeClass();

- если в классе явно задан конструктор с аргументами, то конструктор по умолчанию использоваться не будет, и если нам понадобится
подобный конструктор (без аргументов) то нужно определить его свмостоятельно.

Например экземпляр SomeClassWithConstructor мы можем теперь получить только так (пример):

SomeClassWithConstructor scwc = new SomeClassWithConstructor(1000, 10000, true, "abc");


5. Immutable-классы или объект как константа

Мы можем использовать внутри объекта final-поля и задавать их через конструктор (собственно по другому и не получится),
в результате мы получаем неизменяемый объект (поля в котором не могут быть переопределены):

public class SomeImmutableClass {
    // поля
    final int intField;
    final long longField;
    final boolean booleanField;
    final String stringField;

    // конструктор, инициализирующий все поля
    public SomeImmutableClass(int intField, long longField, boolean booleanField, String stringField) {
       this.intField = intField;
       this.longField = longField;
       this.booleanField = booleanField;
       this.stringField = stringField;
    }

    // методы
    public int getIntField() {
        return this.intField;
    }
}

Если ты обратил внимание, то в этом классе нет set...() методов, т.к. final поля заполняются один раз
при нициализации обьекта в контрукторе и далее не могут быть изменены,
если мы даже добавим сеттер - компилятор не даст собрать такой класс.

Иными словами, final-поле ДОЛЖНО быть инициализировано либо сразу при объявлении, либо в каждом из объявленных конструкторов.

6. Задание 1

- создать в приложении новые классы:

SomeClass
SomeClassWithPrivateFields
SomeClassWithConstructor
SomeImmutableClass

- дополнить классы методами get...() и set...() для всех 4-х полей (я в примерах описал методы только для int поля)

- создать новый стартовый класс для TASK 2 (отличный от Chtoeto) внутри которого:
  - создать по экземпляру вышеперечисленных 4-х классов
  - написать код, заполняющий поля объектов значениями, как при прямом обращению к полю, так и через методы set...()
  - написать код, выводящий в STDOUT значения полей, как путем прямого обращению к полю, так и через методы get...()

7. Задание 2 (extra cost value)

для понимания, стек - это структура данных, которую можно описать как полую трубку,
закрытую с одного конца, в которую мы суем с одного конца шарики со значениями,
т.е. если мы поместили в стек по очереди шарики со значениями 23, 12, 5, 7, 9
то доставать мы их сможем только в следующем порядке: 9, 7, 5, 12, 23

разработать класс Stack для реализации стека из 5 значений int,
необходимо добавить поля для хранения данных и написать код для методов:

public class Stack {

    // поместить значение в стек
    public void put(int a) {
       ...
    }

    // вынуть верхнее значение из стека
    public int pull() {
       ...
    }

    // посмотреть верхнее значение в стеке, но не вынимать
    public int get() {
       ...
    }

    // выдать true если стек полон
    public boolean isFull() {
       ...
    }

    // выдать true если стек пуст
    public boolean isEmpty() {
       ...
    }

}

все необходимое для этого задания пройдено в 2-х уроках


8. вопросы для обсуждения

- чем класс отличается от объекта?
- что такое поля и методы объекта?
- чем приватные поля и методы отличаются от обычных?
- сколько видов методов исходя из наличия параметров и наличия возвращаемого значения можно насчитать?
- какой вид метода при этом можно сравнить с функцией?
- что такое конструктор?
- что такое конструктор по умолчанию?
- может ли конструктор быть приватным?
- что такое immutable-класс?

tasks cost 2000
total cost 3000



--------------------
------ Task 3 ------
--------------------


1. Базовые принципы ООП - инкапсуляция, наследование и полиморфизм

На данный момент мы можем уже базово разобрать два принципа - инкапсуляцию и наследование,
итак,
инкапсуляция (мы по сути уже коснулись этого в примерах) -
это упаковка некоторого поведения (программного кода), определяющего (к примеру) изменение данных объекта (значений полей),
внутрь самого объекта (в частности внутрь методов),
иными словами - инкапсуляция в данном случае означает, что поля:
- недоступны для изменения напрямую снаружи объекта
- изменение полей производится методами самого объекта в рамках правил, заданных программно в самих этих методах.

выше мы как раз разбирали случай с сеттерами:

public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    // сеттер
    public void setIntField(int intField) {
        this.intField = intField;
    }
}

в данном случае метод setIntField() определяет то, как будет изменяться поле intField,
в методе выше значение передается как есть, но к примеру мы можем сделать так:

    public void setIntField(int intField) {
        if (intField >= 0) {
            this.intField = intField;
        }
    }

мы определили условие, при котором поле сможет принимать только положительные значения,
иными словами мы ИНКАПСУЛИРОВАЛИ логику, при которой поле никогда не будет отрицательным.


2. Класс Object и наследование

Наследование в Java - достаточно обширная тема, разбирать будем постепенно.
Сейчас нам достаточно понять то, что в общем случае наследование означает, что все публичные поля и методы
родительского класса наследуются дочерним классом и доступны для использования в объекте дочернего класса без явного объявления.

ВАЖНО: В Java существует родительский класс Object, являющийся предком всех объектов.
От класса Object в Java НЕЯВНО наследуются все объекты (Явное наследование мы разберем чуть ниже).

Для явного объявления наследования текущего класса от любого другого существующего (кроме Object)
используется ключевое слово extends:

// возьмем наш старый пример
public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    // сеттер
    public void setIntField(int intField) {
        this.intField = intField;
    }
}

// и создадим наследника вообще без всего:
public class ChildClassWithPrivateFields extends SomeClassWithPrivateFields {

}

если мы инстанциируем экземпляр ChildClassWithPrivateFields, то публичный метод setIntField будет доступен и в нем:

ChildClassWithPrivateFields ccwpf = new ChildClassWithPrivateFields();
ccwpf.setIntField(12345);

Т.е. иными словами родительский класс будет как бы вложен внутрь дочернего, или наооброт,
дочерний является оболочкой вокруг родительского (можно привести аналогию с матрешкой).


3. Типы ссылок на объект, ключевое слово instanceof и явное приведение типов

Выше мы инстанциировали объект дочернего класса

ChildClassWithPrivateFields ccwpf = new ChildClassWithPrivateFields();

выглядит логично, что тип объектной переменной (ссылки на объект) является собственно типом класса, который мы инстанциируем,
НО, Java позволяет нам в качестве типа ссылки указывать любой родительский тип, если он существует,

например можно сделать так:
SomeClassWithPrivateFields ccwpf = new ChildClassWithPrivateFields();

или даже так:
Object ccwpf = new ChildClassWithPrivateFields();

здесь ВАЖНО понимать, что во всех этих случаях будет создан объект класса ChildClassWithPrivateFields,
т.е. иными словами тип создаваемого объекта всегда определяется тем что указано после ключевого слова new,
в нашем случае:
new ChildClassWithPrivateFields()

а тип ссылки указывает на то, какие методы и поля нам будут доступны, т.е. мы получим доступ только к тем полям и методам, которые доступны в классе,
который объявлен для объектной переменной (ссылки на объект) - ccwpf.

Далее, допустим мы где-то в коде присвоили ссылке (переменной)

Object o

какой-то объект,
как нам проверить, экземпляром какого класса является этот объект?
Одним из способов является использование ключевого слова instanceof,
оно позволяет проверить, является ли объект по ссылке (переменной) экземпляром конкретного класса,
условие (для проверки на экземпляр ChildClassWithPrivateFields) будет выглядить так:

o instanceof ChildClassWithPrivateFields

условие возвратит true, если o является экземпляром класса ChildClassWithPrivateFields,
в противном случае возвратит false.

Далее, а можем ли мы, имея переменную

Object o

которая на самом деле указывает на объект класса ChildClassWithPrivateFields (и мы в этом уверены)
каким то образом переопределить переменную на тип ChildClassWithPrivateFields чтобы использовать методы этого класса?
Да, можем,
для этого нам нужно объявить еще одну переменную нужного типа и воспользоваться ЯВНЫМ преобразованием типов, которое
в коде выглядит так:

ChildClassWithPrivateFields сс = (ChildClassWithPrivateFields) o;

Хорошим тоном (чтобы не нарваться на ошибку приведения типов) является как раз проверять тип объекта
перед таким преобразованием:

if (o instanceof ChildClassWithPrivateFields) {
    ChildClassWithPrivateFields сс = (ChildClassWithPrivateFields) o;
    // далее какой-то код
    ...
}


4. Ключевое слово null

Слово null используется для инициализации объектных полей и переменных (ссылок на объекты), а также
в проверочных условиях,
ранее мы задавали объектную переменную следующим образом (например):

SomeClassWithPrivateFields ccwpf = new ChildClassWithPrivateFields();

То же самое можно сделать следующим образом:

// объявление переменной и присвоение ей значения null -
// иначе говоря - переменная сейчас НЕ содержит ссылки на какой либо объект
SomeClassWithPrivateFields ccwpf = null;
// ...  здесь может быть какой-то код ...

// присвоение переменной ссылки на только что созданный объект
ccwpf = new ChildClassWithPrivateFields();

т.е. еще раз, null означает, что переменной не присвоен никакой объект
или говоря более правильно - переменная не содержит ССЫЛКИ на объект

также мы может использовать null в проверочном условии:

if (ccwpf == null) {
  // что то делаем
)


5. Ключевые слова this и super

Ранее, я давал краткое пояснение по поводу ключевого слова this -
оно означает. что мы обращаемся к полю (либо методу) конкретного ЭКЗЕМПЛЯРА (объекта класса),
на примере покажу более развернуто:

public class SomeClassWithPrivateFields {
    // поля - ИМЕННО на них указывает слово this
    private int intField;

    public int getIntField() {
        return this.intField;
    }

    public void setIntField(int intField) {
        this.intField = intField;
    }
}

this говорит, что мы хотим обратить к ПОЛЮ экземпляра, т.е. к переменной определенной на уровне самого объекта,
на примере метода setIntField это очень хорошо видно, т.к. там используется присвоение
        this.intField = intField;
т.е. полю объекта intField присваивается значение параметра метода intField - у переменных здесь одинаковые имена,
но компилятор отличает их, потому что левое помечено префиксом this.
Если мы сделаем так:
        intField = intField;
ошибки компиляции не будет - никто не мешает нам присвоить переменной метода ее же значение,
но метод будет работать неправильно, т.к. поле класса intField здесь не затрагивается.

Ключевое слово super используется для унаследованных объектов и означает, что мы хотим получить
НЕПОСРЕДСТВЕННЫЙ доступ к полю либо методу родительского объекта:

// родительский класс
public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    // сеттер
    public void setIntField(int intField) {
        this.intField = intField;
    }
}

// наследник
public class ChildClassWithPrivateFields extends SomeClassWithPrivateFields {
    // переопределяем метод родительского класса
    public void setIntField(int intField) {
        // обращаемся к методу родительского объекта SomeClassWithPrivateFields
        // только если аргумент > 100
        if (intField > 100) {
            super.setIntField(intField);
        }
    }
}

в результате получается, что метод setIntField наследника будет иметь другое поведение,
нежели оригинальный метод setIntField родительского класса.

6. Условия и циклы

ранее мы уже касались немного этой темы, сейчас просто дам для понимания синтаксис с примерами,

условный оператор (условие - ВЫРАЖЕНИЕ, возвращающее true или false):

if (условие) {
    ...
} else {
    ...
}

else является опциональным (необязательным),
еще есть однострочная модификация условного выражения:

    условие ? исполняемое_выражение1 : исполняемое_выражение2

где исполняемое_выражение1 - выполнится, если условие истинно, исполняемое_выражение2 выполнится если условие ложно

простой условный цикл:

// тело цикла (внутри скобок) будет выполняться до тех пор, пока условие истинно
while (условие) {
    ... тело цикла
}

если мы к примеру сделаем так:

while (true) {
    ... тело цикла
}

то получим бесконечный цикл

цикл со счетчиком:

// здесь мы задаем параметры счетчика тремя фразами, разделенными точкой с запятой
// 1. определяем числовую переменную i с начальным значением = 0
// 2. задаем условие выполнения цикла: цикл будет выполняться пока i < 1000
// 3. задаем увеличение (инкремент) переменной i с каждым шагом цикла
//    здесь надо понимать, что i++ это просто сокращенный вариант выражения i = i + 1
for (int i = 0; i < 1000; i++)
    ... тело цикла
}

такой цикл будет выполняться 1000 раз.


7. вопросы

- что такое инкапсуляция?
- как ты понял наследование?
- что за класс Object?
- что такое явное и неяное наследование?
- всегда ли тип объектной переменной должен совпадать с типом присваемого объекта?
- что такое ключевое слово instanceof?
- что такое явное приведение типов?
- что такое null?
- как ты понял this и super? чем они отличаются?


8. задание

Создать новый класс CheckedStack, который должен быть унаследован от Stack,
и переопределить в нем методы put() pull() и get() таким образом, чтобы в этих методах
стек проверялся соответственно на то, что он уже полон (в put) и на то что он пуст (в pull и get),
в случае если новое значение не может быть помещено в стек либо нет значений в стеке для выборки -
выводить соответствующее сообщение и завершать работу метода, иначе передавать выполнение
соответствующему методу родительского класса.
(Я помню, что мы такое поведение уже определили в самом классе Stack, и нам тогда получается нужно
перенести часть существующего поведения методов из Stack в CheckedStack)

tasks cost 1000
total cost 4000





--------------------
------ Task 4 ------
--------------------

1. Классы-оболочки для примитивных типов

Вспомним, какие базовые примитивные типы существуют в Java:
byte - базовый целочисленный тип размером в один байт
int - базовый целочисленный тип
long - расширенный целочисленный тип
float - базовый вещественный тип
double - расширенный вещественный тип
boolean - логичеcкий тип, может принимать значения true или false

НО, помимо примитивных типов, существуют объектные типы (классы) для всех вышеперечисленных типов данных:
Byte
Integer
Long
Float
Double
Boolean

такие классы принято называть классами-обертками, потому что по сути они являются
классом, который содержит поле примитивного типа.

Очень грубо это выглядит так к примеру:

public class Integer {
    int value;
}

Сразу возникает вопрос - а зачем это надо?

Во первых, мы получаем не просто обертку, а некоторое инкапсулированное поведение
(набор методов в части преобразования из других типов и прочее)

Во вторых, есть важное отличие в части способа хранения разных типов в памяти,
мы его разберем чуть ниже.


2. Неявные преобразования примитивных типов

Java умеет неявно преобразовывать примитивные типы в типы обертки,
поясню на примере:
переменную примитивного типа мы объявляем и инициализируем так:

int a = 123;

но для переменной объектного типа мы должны вызвать конструктор:

Integer intValue = new Integer(123);

Так вот, для типов-оберток мы можем использовать неявный синтаксис,
Java сама при выполнении вызовет конструктор или выполнит вызов метода:

Integer intValue = 123;

и далее можно сделать так:

int a = intValue;

Java сама преобразует объект в примитивный тип.



3. Многомерные массивы и вложенные циклы

Немного развернем тему с массивами,
Ранее мы использовали только одномерные массивы, которые объявляются так (пример для чисел):

int[] array = new int[100]; //где 100 - размер массива

но Java поддерживает массивы любого уровня, не только одномерные,
чтобы объявить двумерный массив, используем такое выражение:

int[][] matrix = new int[100][100];

такие массивы называются матрицами, в примере выше мы создали матрицу размером 100*100

соответственно, для доступа к ячейке матрицы нам уже нужно 2 указателя:

int x = 0;
int y = 0;

//выводим значение ячейки матрицы

System.out.println(matrix[x][y]);

для обхода всех значений матрицы удобно использовать не один цикл, а два, вложенных один в другой:

for (int x = 0; i < 100; i++) {
    for (int y = 0; y < 100; y++) {
        System.out.println(matrix[x][y]);
    }
}


4. ВАЖНАЯ ТЕМА. Отличие переменных примитивного типа и объектов, организация памяти

Начнем немного касаться очень важной темы, затрагивающей организацию памяти во время выполнения программы.
Почему эта тема важная - потому что здесь приобретается понимание того как могут себя вести внутри программы
переменные и поля разных типов и с какими неожиданностями мы можем столкнуться.

Внутри JVM существует два вида памяти:

Стек (Stack)
и
Куча (Heap)

Грубо говоря, стек - это пространство непосредственного выполнения кода,
Куча - это хранилище ОБЪЕКТОВ,
чтобы объект мог храниться в куче, где-то на стеке должен существовать указатель на это место в памяти.

Что важно понять,
ВСЕ примитивные типы и ссылки на объекты (объектные переменные) - ХРАНЯТСЯ НА СТЕКЕ
объекты - ХРАНЯТСЯ В КУЧЕ.

Пока все по этой теме, будем потихоньку ее изучать.


5. метод equals() и сравнение объектов

метод equals() предназначен для сравнения текущего объекта с другим объектом (экземпляром) ЭТОГО ЖЕ класса
метод equals() интересен тем, что этот метод изначально определен в классе Object и в нем он работает таким образом,
что сравнивает системные уникальные идентификаторы объектов, и т.к. каждый идентификатор уникален,
то получается что и каждый из объектов также будет уникален и не равен никакому другому (метод будет возвращать false если
только мы не сравниваем объект с самим собой),
чтобы сравнивать объекты исходя из их реального назначения, метод equals должен быть ПЕРЕОПРЕДЕЛЕН в текущем объекте
и внутри метода должно быть запрограммировано соответствующее поведение, иными словами,
правила сравнивания объектов некоторого класса должны быть ИНКАПСУЛИРОВАНЫ в методе equals() класса.

// и опять возьмем наш старый пример
public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    public int getIntField() {
        return this.intField;
    }

    public void setIntField(int intField) {
        this.intField = intField;
    }
}

если мы хотим сравнивать объекты данного класса исходя из того значения, которое будет присвоено полю intField,
то нам нужно ПЕРЕОПРЕДЕЛИТЬ метод equals() родительского класса Object:

public class SomeClassWithPrivateFields {
    // поля
    private int intField;

    public int getIntField() {
        return this.intField;
    }

    public void setIntField(int intField) {
        this.intField = intField;
    }

    @Override
    public boolean equals(Object o) {
        // проверяем, что в метод пришел именно экземпляр SomeClassWithPrivateFields
        if (o instanceof SomeClassWithPrivateFields) {
            // приводим аргумент метода к текущему типу объекта, чтобы мы могли обратиться к его методу
            SomeClassWithPrivateFields scwpf = (SomeClassWithPrivateFields) o;
            if (this.intField == scwpf.getIntField()) {
                return true;
            }
        }
        return false;
    }
}

лирическое отступление:
над описанием метода equals() мы видим такую загогулину: @Override
это называется АННОТАЦИЯ
Аннотация вообще, это нечто среднее между комментарием и исполняемым кодом, сами аннотации не являются ключевым словом для
выполнения какого-то действия, но могут указывать компилятору либо самой java-машине (JRE, Java Runtime Environment)
на необходимость каких-то дополнительных действий типа проверок и т.п.
Тему с аннотациями мы будем разбирать позже, в данном случае мы коснулись аннотации @Override и я решил это сразу пояснить.
Хорошим тоном является помечать аннотацией @Override каждый переопределяемый метод.
На работе программы это НИКАК не сказывается, все будет работать и без данной аннотации,
НО,
@Override говорит компилятору, что данный метод переопределен, т.е. у родительского класса должен быть аналогичный метод,
если у родительского класса аналогичный метод остутствует - компилятор выдаст предупреждение,
это сделано для использования в больших проектах для помощи в отслеживании труднообнаружимых ошибок.
конец лирического отступления


Вопросы:

что такое классы-обертки?
посмотри на внутреннее устройство класса Integer (или Long) и постарайся понять, что выполняет тот или иной метод
как работает неявное преобразование примитивных типов в обертки и наоборот?
что такое многомерный массив? что такое матрица?
как ты понял, что такое стек и куча в применении к организации памяти?
для чего в классе переопределять метод equals() и нужно ли это делать в каждом классе обязательно?


Задание:

Написать программу, которая создает матрицу размером 10 на 10,
заполнить ее произвольными значениями и вывести ее на экран

tasks cost 1000
total cost 5000

дополнительное задание

взять целочисленный массив и заполнить его произвольными значениями
создать рядом аналогичный массив и написать алгоритм,
который переместит значения из первого массива таким образом,
чтобы они были выстроены по порядку - от меньшего к большему
Иначе говоря - отсортировать



--------------------
------ Task 5 ------
--------------------

1. Еще раз разжуем по поводу видимости переменных (класc, метод, циклы/условия)

Если мы посмотрим еще раз на структуру класса (и вообще java-программы), то легко заметить, что
структура формируется фигурными скобками, иначе говоря, содержимое класса ограничено фигурными скобками,
содержимое методов ограничено фигурными скобками внутри класса, содержимое таких элементов как циклы
и условия также огрничено фигурными скобками внутри методов.

Таким образом правила видимости переменных можнол описать так:
- публичная переменная, объявленная в классе, будет видна везде в методах класса (и соответственно в любых структурах внутри метода),
  а также к ней можно обращаться из других классов
- приватная переменная, объявленная в классе, будет видна везде в методах класса (и соответственно в любых структурах внутри метода)
- переменная, объвленная внутрм метода, будет видная только в данном методе и в любых структурах внутри метода
- переменная, объявленная внутри структуры (цикла, условия), будет видна только в данной структуре и во всех вложенных
  структурах внутри нее

Также из этого следует, что модификаторы public, private могут быть применимы только к переменным, объявленным на уровне класса,
для переменных внутри методов и структур такие модификаторы не имеют смысла.



2. Далее по поводу особенностей и отличий примитивных и объектных переменных

Факультативно мы рассмотрели отличия в хранении в памяти переменных примитивных типов
и объектных типов. Для закрепления темы, повторим что:

- все переменные примитивных типов хранятся непосредственно на стеке (stack)
(помним, что стек - это пространство непоредственного выполнения программного кода),
- также на стеке хранятся объектные переменные - ССЫЛКИ на объекты,
сами объекты при этом хранятся в куче (heap),

понимание этого необходимо для того, чтобы понимать как будут присваиваться значения
тем или иным переменным,
если в случае переменной примитивного типа В ЛЮБОМ СЛУЧАЕ присваивания переменная
получает ЗНАЧЕНИЕ, иными словами на примере:

int a = 100;
int b = a;

в этом случае каждая из переменных будет содержать свое отдельное значение 100 на стеке,
и дальнейшее изменение любой из этих переменных никак не повлияет на значение другой.

В случае с объектными переменными ситуация несколько другая:

SomeClass a = new SomeClass();
SomeClass b = a;

Здесь нужно просто понять тот факт, что переменная по сути не содержит объект, а просто УКАЗЫВАЕТ на адрес в heap-е.
Поэтому строчка:
SomeClass b = a;
не создаст нам новый объект (помним, что инстанциирование нового объекта всегда требует ключевого слова new),
а просто скопирует ЗНАЧЕНИЕ ссылки из переменной а в переменную b.
В результате a и b у нас будут указывать на ОДИН И ТОТ ЖЕ объект.



3. Циклы. Операторы continue, break

Ранее мы использовали циклы, которые безусловно выполняют весь объем кода,
заключенный в скобках все необходимое кол-во итераций,
но существуют дополнительные операторы управления циклом, которые могут быть полезны в ряде случаев,

возьмем цикл:

for (int x = 0; x < 1000; x++) {
    System.out.println(x);
    System.out.println("OK");
}

такой цикл нам выведет что-то вроде:

0
ОК
1
ОК
2
ОК
... и т.д.

Оператор continue продолжит выполнение непосредственно со следующей итерации цикла (если она существует),
т.е. внутри самого цикла после выполнения continue весь оставшийся код будет проигнорирован:

for (int x = 0; x < 1000; x++) {
    System.out.println(x);
    if (x > 0) {
        continue;
    }
    System.out.println("OK");
}

выведет:

0
ОК
1
2
3
... и т.д.

Выполнение оператора break приводит к выходу из цикла и продолжению выполнения программы
со следующего предложения после цикла:

for (int x = 0; x < 1000; x++) {
    System.out.println(x);
    if (x > 0) {
        break;
    }
    System.out.println("OK");
}

выведет:

0
ОК
1



4. Java packages, слова public, protected, private, final classes

Java package (пакет) - это структурный элемент программного приложения (проекта),
говоря простыми словами - это некоторая папка внутри папки src, содержащая классы Java.
Служит целям упорядочивания классов, в случае если их количество уже достаточно велико,
и мы можем разделить их на группы, по некоторым признакам (целям, содержимому и т.д.).
Для указания принадлежности класса к некоторому пакету используется ключевое слово package,
которое объявляется до собственно объявления класса:

package myclasses;

public class SomeClass {
    //
    public int getIntField() {
        //
    }
}

Ранее мы рассмотрели модификаторы public и private для полей и методов, выше еще раз повторили
как эти модификаторы влияют на видимость переменных,
но помимо них существуют еще 2 модификатора:

модификатор по умолчанию (без ключевого слова), т.е. когда поле (или метод) объявляется так:

int a;
int getIntField()

означает что поле или метод будут доступны только в пределах пакета класса,

модификатор protected означает что поле или метод будут доступны только в пределах пакета класса,
а также во всех наследниках данного класса, даже если они лежат в другом пакете.

Ранее, мы использовали ключевое слово final только в применении к полям класса (константы),
Но, также мы можем объявлять и финальные классы:

public final class SomeClass {
    //
    public int getIntField() {
        //
    }
}

Это означает, что мы запрещаем наследование от этого класса.
Иными словами,  реализация такого класса является окончательной и не подлежит изменению в наследниках.



5. Абстрактные классы и абстрактные методы

АБстрактный класс - это класс, для которого не может быть инстанциирован объект,
т.е. мы не можем выполнить оператор new для такого класса.

Задача абстрактных классов - исключительно быть ПРЕДКАМИ для классов обычных,
иными словами, некий абстрактный класс может содержать неполный функционал для какой-либо задачи,
и в наследниках по разному реализовывать окнчательные варианты решений для такой задачи.

Помимо абстрактных классов, мы можем создавать абстрактные методы - методы, которые не имеют реализации,
а только объявление. В коде такие методы отличаются тем что не имеют выполняемого тела (в фигурных скобках),
а заканчиваются точкой с запятой сразу после объявления.
ВАЖНО: Абстрактный метод обязательно должен переопределен (override) в классе наследнике, таким образом
должен получить конкретную реализацию. Тут важно еще понимать, что от абстрактого класса может быть
унаследован еще один абстрактный класс, но в результате первый не-абстрактный наследник должен
описать реализацию всех ранее сущетствовавших абстрактных методов.

Объявляется абстрактный класс так:

public abstract class SomeClass {
    // а абстрактный метод - вот так - без фигурных скобок:
    public abstract int getIntField();
}


6. Класс String и его методы

indexOf("")
поиск позиции подстроки в строке, если подстрока не найдена - возвращает -1

startWith("")
возвращает true, если строка начинается с указанной подстроки

endsWith("")
возвращает true, если строка заканчивается указанной подстрокой

substring(start, len)
возвращает подстроку, которая начинается с позиции start в строке и имеет длину len

toUpperCase()
приводит строку к верхнему регистру (для алфавитных символов)

toLowerCase()
приводит строку к нижнему регистру (для алфавитных символов)

trim()
обрезает пробелы у строки слева и справа (если есть)

split("")
принимает разделитель в качестве аргумента и возвращает массив значений, полученных разбиением строки

replace("","")
ищет подстроку (первый аргумент) и если найдена - заменяет ее в строке на другую (второй аргумент)

isEmpty()
возвращает true, если строка пустая ("")

length()
возвращает длину строки (целое число)

concat("")
аналог выражения + для String - объединяет текущую строку с аргументом

compareTo("")
сравнивает одну строку с другой
возвращает 1 если строка "больше"
возвращает 0 если строка идентична
возращает -1 если строка меньше

equals("")
возвращает true если строка идентична

equalsIgnoreCase("")
возвращает true если строка идентична без учета регистра символов



Задание:

написать примеры для всех вышеразобранных методов класса String,
которые бы НАГЛЯДНО демонстрировали работу этих методов.
Т.е. берешь для каждого примера какой-то String:

String s = "abcdefgijklmn";

И делаешь что-то типа:

System.out.println("Ищем позицию подстроки dfg в строке abcdefgijklmn");
System.out.println(s.indexOf("dfg"));

и так для каждого метода

Дополнительное задание:

написать класс,
Класс должен содержать целочисленный массив и инкапсулировать методы для управления данными в массиве:

// добавление числа в массив
void add(int a)

// получение числа из массива по индексу
int get(int i)

Казалось бы просто, но есть один момент - мы не знаем заранее, сколько нам чисел понадобится добавить в массив,
метод add должен как-то уметь обрабатывать этот момент, учитывая то что массив заранее создается с конечным числом элементов.